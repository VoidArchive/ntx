// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: backup.sql

package database

import (
	"context"
	"database/sql"
)

const createBackupRecord = `-- name: CreateBackupRecord :execresult

INSERT INTO backup_history (backup_path, backup_size, created_at, notes)
VALUES (?, ?, ?, ?)
`

type CreateBackupRecordParams struct {
	BackupPath string         `json:"backup_path"`
	BackupSize sql.NullInt64  `json:"backup_size"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	Notes      sql.NullString `json:"notes"`
}

// Backup History Operations
func (q *Queries) CreateBackupRecord(ctx context.Context, arg CreateBackupRecordParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createBackupRecord,
		arg.BackupPath,
		arg.BackupSize,
		arg.CreatedAt,
		arg.Notes,
	)
}

const deleteBackupRecord = `-- name: DeleteBackupRecord :exec
DELETE FROM backup_history WHERE id = ?
`

func (q *Queries) DeleteBackupRecord(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBackupRecord, id)
	return err
}

const getAllBackupRecords = `-- name: GetAllBackupRecords :many
SELECT id, backup_path, backup_size, created_at, restored_at, notes
FROM backup_history
ORDER BY created_at DESC
`

func (q *Queries) GetAllBackupRecords(ctx context.Context) ([]BackupHistory, error) {
	rows, err := q.db.QueryContext(ctx, getAllBackupRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupHistory
	for rows.Next() {
		var i BackupHistory
		if err := rows.Scan(
			&i.ID,
			&i.BackupPath,
			&i.BackupSize,
			&i.CreatedAt,
			&i.RestoredAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupRecord = `-- name: GetBackupRecord :one
SELECT id, backup_path, backup_size, created_at, restored_at, notes
FROM backup_history
WHERE id = ?
`

func (q *Queries) GetBackupRecord(ctx context.Context, id int64) (BackupHistory, error) {
	row := q.db.QueryRowContext(ctx, getBackupRecord, id)
	var i BackupHistory
	err := row.Scan(
		&i.ID,
		&i.BackupPath,
		&i.BackupSize,
		&i.CreatedAt,
		&i.RestoredAt,
		&i.Notes,
	)
	return i, err
}

const getBackupStats = `-- name: GetBackupStats :one
SELECT 
    COUNT(*) as total_backups,
    COALESCE(SUM(backup_size), 0) as total_size,
    MAX(created_at) as latest_backup
FROM backup_history
`

type GetBackupStatsRow struct {
	TotalBackups int64       `json:"total_backups"`
	TotalSize    interface{} `json:"total_size"`
	LatestBackup interface{} `json:"latest_backup"`
}

func (q *Queries) GetBackupStats(ctx context.Context) (GetBackupStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getBackupStats)
	var i GetBackupStatsRow
	err := row.Scan(&i.TotalBackups, &i.TotalSize, &i.LatestBackup)
	return i, err
}

const getRecentBackups = `-- name: GetRecentBackups :many
SELECT id, backup_path, backup_size, created_at, restored_at, notes
FROM backup_history
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentBackups(ctx context.Context, limit int64) ([]BackupHistory, error) {
	rows, err := q.db.QueryContext(ctx, getRecentBackups, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupHistory
	for rows.Next() {
		var i BackupHistory
		if err := rows.Scan(
			&i.ID,
			&i.BackupPath,
			&i.BackupSize,
			&i.CreatedAt,
			&i.RestoredAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBackupRestore = `-- name: UpdateBackupRestore :exec
UPDATE backup_history
SET restored_at = ?
WHERE id = ?
`

type UpdateBackupRestoreParams struct {
	RestoredAt sql.NullTime `json:"restored_at"`
	ID         int64        `json:"id"`
}

func (q *Queries) UpdateBackupRestore(ctx context.Context, arg UpdateBackupRestoreParams) error {
	_, err := q.db.ExecContext(ctx, updateBackupRestore, arg.RestoredAt, arg.ID)
	return err
}
