// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes, created_at
`

type CreateTransactionParams struct {
	PortfolioID     int64          `json:"portfolio_id"`
	Symbol          string         `json:"symbol"`
	TransactionType string         `json:"transaction_type"`
	Quantity        int64          `json:"quantity"`
	PricePaisa      int64          `json:"price_paisa"`
	CommissionPaisa sql.NullInt64  `json:"commission_paisa"`
	TaxPaisa        sql.NullInt64  `json:"tax_paisa"`
	TransactionDate time.Time      `json:"transaction_date"`
	Notes           sql.NullString `json:"notes"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transactions, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.PortfolioID,
		arg.Symbol,
		arg.TransactionType,
		arg.Quantity,
		arg.PricePaisa,
		arg.CommissionPaisa,
		arg.TaxPaisa,
		arg.TransactionDate,
		arg.Notes,
	)
	var i Transactions
	err := row.Scan(
		&i.ID,
		&i.PortfolioID,
		&i.Symbol,
		&i.TransactionType,
		&i.Quantity,
		&i.PricePaisa,
		&i.CommissionPaisa,
		&i.TaxPaisa,
		&i.TransactionDate,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = ?
`

func (q *Queries) DeleteTransaction(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const getPortfolioTransactionStats = `-- name: GetPortfolioTransactionStats :one
SELECT 
    COUNT(*) as total_transactions,
    SUM(CASE WHEN transaction_type = 'buy' THEN 1 ELSE 0 END) as buy_count,
    SUM(CASE WHEN transaction_type = 'sell' THEN 1 ELSE 0 END) as sell_count,
    SUM(CASE WHEN transaction_type = 'buy' THEN quantity * price_paisa ELSE 0 END) as total_invested_paisa,
    SUM(CASE WHEN transaction_type = 'sell' THEN quantity * price_paisa ELSE 0 END) as total_realized_paisa,
    SUM(commission_paisa + tax_paisa) as total_fees_paisa
FROM transactions 
WHERE portfolio_id = ?
`

type GetPortfolioTransactionStatsRow struct {
	TotalTransactions  int64           `json:"total_transactions"`
	BuyCount           sql.NullFloat64 `json:"buy_count"`
	SellCount          sql.NullFloat64 `json:"sell_count"`
	TotalInvestedPaisa sql.NullFloat64 `json:"total_invested_paisa"`
	TotalRealizedPaisa sql.NullFloat64 `json:"total_realized_paisa"`
	TotalFeesPaisa     sql.NullFloat64 `json:"total_fees_paisa"`
}

func (q *Queries) GetPortfolioTransactionStats(ctx context.Context, portfolioID int64) (GetPortfolioTransactionStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getPortfolioTransactionStats, portfolioID)
	var i GetPortfolioTransactionStatsRow
	err := row.Scan(
		&i.TotalTransactions,
		&i.BuyCount,
		&i.SellCount,
		&i.TotalInvestedPaisa,
		&i.TotalRealizedPaisa,
		&i.TotalFeesPaisa,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes, created_at FROM transactions WHERE id = ?
`

func (q *Queries) GetTransaction(ctx context.Context, id int64) (Transactions, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transactions
	err := row.Scan(
		&i.ID,
		&i.PortfolioID,
		&i.Symbol,
		&i.TransactionType,
		&i.Quantity,
		&i.PricePaisa,
		&i.CommissionPaisa,
		&i.TaxPaisa,
		&i.TransactionDate,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionSummary = `-- name: GetTransactionSummary :one
SELECT 
    symbol,
    SUM(CASE WHEN transaction_type = 'buy' THEN quantity ELSE -quantity END) as net_quantity,
    SUM(CASE WHEN transaction_type = 'buy' THEN quantity * price_paisa ELSE 0 END) as total_buy_value_paisa,
    SUM(CASE WHEN transaction_type = 'sell' THEN quantity * price_paisa ELSE 0 END) as total_sell_value_paisa,
    SUM(commission_paisa + tax_paisa) as total_fees_paisa
FROM transactions 
WHERE portfolio_id = ? AND symbol = ?
GROUP BY symbol
`

type GetTransactionSummaryParams struct {
	PortfolioID int64  `json:"portfolio_id"`
	Symbol      string `json:"symbol"`
}

type GetTransactionSummaryRow struct {
	Symbol              string          `json:"symbol"`
	NetQuantity         sql.NullFloat64 `json:"net_quantity"`
	TotalBuyValuePaisa  sql.NullFloat64 `json:"total_buy_value_paisa"`
	TotalSellValuePaisa sql.NullFloat64 `json:"total_sell_value_paisa"`
	TotalFeesPaisa      sql.NullFloat64 `json:"total_fees_paisa"`
}

func (q *Queries) GetTransactionSummary(ctx context.Context, arg GetTransactionSummaryParams) (GetTransactionSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionSummary, arg.PortfolioID, arg.Symbol)
	var i GetTransactionSummaryRow
	err := row.Scan(
		&i.Symbol,
		&i.NetQuantity,
		&i.TotalBuyValuePaisa,
		&i.TotalSellValuePaisa,
		&i.TotalFeesPaisa,
	)
	return i, err
}

const listTransactionsByDateRange = `-- name: ListTransactionsByDateRange :many
SELECT id, portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes, created_at FROM transactions 
WHERE portfolio_id = ?1 AND transaction_date BETWEEN ?2 AND ?3
ORDER BY transaction_date DESC, created_at DESC
`

type ListTransactionsByDateRangeParams struct {
	PortfolioID int64     `json:"portfolio_id"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
}

func (q *Queries) ListTransactionsByDateRange(ctx context.Context, arg ListTransactionsByDateRangeParams) ([]Transactions, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByDateRange, arg.PortfolioID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transactions{}
	for rows.Next() {
		var i Transactions
		if err := rows.Scan(
			&i.ID,
			&i.PortfolioID,
			&i.Symbol,
			&i.TransactionType,
			&i.Quantity,
			&i.PricePaisa,
			&i.CommissionPaisa,
			&i.TaxPaisa,
			&i.TransactionDate,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByPortfolio = `-- name: ListTransactionsByPortfolio :many
SELECT id, portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes, created_at FROM transactions 
WHERE portfolio_id = ? 
ORDER BY transaction_date DESC, created_at DESC
`

func (q *Queries) ListTransactionsByPortfolio(ctx context.Context, portfolioID int64) ([]Transactions, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByPortfolio, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transactions{}
	for rows.Next() {
		var i Transactions
		if err := rows.Scan(
			&i.ID,
			&i.PortfolioID,
			&i.Symbol,
			&i.TransactionType,
			&i.Quantity,
			&i.PricePaisa,
			&i.CommissionPaisa,
			&i.TaxPaisa,
			&i.TransactionDate,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsBySymbol = `-- name: ListTransactionsBySymbol :many
SELECT id, portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes, created_at FROM transactions 
WHERE portfolio_id = ? AND symbol = ? 
ORDER BY transaction_date DESC, created_at DESC
`

type ListTransactionsBySymbolParams struct {
	PortfolioID int64  `json:"portfolio_id"`
	Symbol      string `json:"symbol"`
}

func (q *Queries) ListTransactionsBySymbol(ctx context.Context, arg ListTransactionsBySymbolParams) ([]Transactions, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsBySymbol, arg.PortfolioID, arg.Symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transactions{}
	for rows.Next() {
		var i Transactions
		if err := rows.Scan(
			&i.ID,
			&i.PortfolioID,
			&i.Symbol,
			&i.TransactionType,
			&i.Quantity,
			&i.PricePaisa,
			&i.CommissionPaisa,
			&i.TaxPaisa,
			&i.TransactionDate,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions 
SET symbol = ?, transaction_type = ?, quantity = ?, price_paisa = ?, 
    commission_paisa = ?, tax_paisa = ?, transaction_date = ?, notes = ?
WHERE id = ?
RETURNING id, portfolio_id, symbol, transaction_type, quantity, price_paisa, commission_paisa, tax_paisa, transaction_date, notes, created_at
`

type UpdateTransactionParams struct {
	Symbol          string         `json:"symbol"`
	TransactionType string         `json:"transaction_type"`
	Quantity        int64          `json:"quantity"`
	PricePaisa      int64          `json:"price_paisa"`
	CommissionPaisa sql.NullInt64  `json:"commission_paisa"`
	TaxPaisa        sql.NullInt64  `json:"tax_paisa"`
	TransactionDate time.Time      `json:"transaction_date"`
	Notes           sql.NullString `json:"notes"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transactions, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.Symbol,
		arg.TransactionType,
		arg.Quantity,
		arg.PricePaisa,
		arg.CommissionPaisa,
		arg.TaxPaisa,
		arg.TransactionDate,
		arg.Notes,
		arg.ID,
	)
	var i Transactions
	err := row.Scan(
		&i.ID,
		&i.PortfolioID,
		&i.Symbol,
		&i.TransactionType,
		&i.Quantity,
		&i.PricePaisa,
		&i.CommissionPaisa,
		&i.TaxPaisa,
		&i.TransactionDate,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
