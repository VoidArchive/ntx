// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"ntx/internal/data/models"
)

const calculateAverageCost = `-- name: CalculateAverageCost :one
SELECT 
    CASE 
        WHEN SUM(CASE WHEN type = 'buy' THEN quantity ELSE 0 END) = 0 THEN 0
        ELSE SUM(CASE WHEN type = 'buy' THEN total_amount ELSE 0 END) / 
             SUM(CASE WHEN type = 'buy' THEN quantity ELSE 0 END)
    END as avg_cost
FROM transactions
WHERE symbol = ? COLLATE NOCASE
`

func (q *Queries) CalculateAverageCost(ctx context.Context, symbol string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, calculateAverageCost, symbol)
	var avg_cost interface{}
	err := row.Scan(&avg_cost)
	return avg_cost, err
}

const createTransaction = `-- name: CreateTransaction :execresult

INSERT INTO transactions (type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTransactionParams struct {
	Type        string          `json:"type"`
	Symbol      string          `json:"symbol"`
	Quantity    models.Quantity `json:"quantity"`
	Price       int64           `json:"price"`
	TotalAmount models.Money    `json:"total_amount"`
	Fees        models.Money    `json:"fees"`
	Date        time.Time       `json:"date"`
	Notes       sql.NullString  `json:"notes"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	UpdatedAt   sql.NullTime    `json:"updated_at"`
}

// Transaction Operations
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTransaction,
		arg.Type,
		arg.Symbol,
		arg.Quantity,
		arg.Price,
		arg.TotalAmount,
		arg.Fees,
		arg.Date,
		arg.Notes,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = ?
`

func (q *Queries) DeleteTransaction(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const getAllTransactions = `-- name: GetAllTransactions :many
SELECT id, type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at
FROM transactions
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetAllTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getAllTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Symbol,
			&i.Quantity,
			&i.Price,
			&i.TotalAmount,
			&i.Fees,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTransactions = `-- name: GetRecentTransactions :many
SELECT id, type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at
FROM transactions
ORDER BY date DESC, created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentTransactions(ctx context.Context, limit int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getRecentTransactions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Symbol,
			&i.Quantity,
			&i.Price,
			&i.TotalAmount,
			&i.Fees,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at
FROM transactions
WHERE id = ?
`

func (q *Queries) GetTransaction(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Symbol,
		&i.Quantity,
		&i.Price,
		&i.TotalAmount,
		&i.Fees,
		&i.Date,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionSummary = `-- name: GetTransactionSummary :one
SELECT 
    symbol,
    COUNT(*) as total_transactions,
    SUM(CASE WHEN type = 'buy' THEN quantity ELSE -quantity END) as net_quantity,
    SUM(CASE WHEN type = 'buy' THEN total_amount ELSE 0 END) as total_invested,
    SUM(CASE WHEN type = 'sell' THEN total_amount ELSE 0 END) as total_received,
    SUM(fees) as total_fees
FROM transactions
WHERE symbol = ? COLLATE NOCASE
`

type GetTransactionSummaryRow struct {
	Symbol            string          `json:"symbol"`
	TotalTransactions int64           `json:"total_transactions"`
	NetQuantity       sql.NullFloat64 `json:"net_quantity"`
	TotalInvested     sql.NullFloat64 `json:"total_invested"`
	TotalReceived     sql.NullFloat64 `json:"total_received"`
	TotalFees         sql.NullFloat64 `json:"total_fees"`
}

func (q *Queries) GetTransactionSummary(ctx context.Context, symbol string) (GetTransactionSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionSummary, symbol)
	var i GetTransactionSummaryRow
	err := row.Scan(
		&i.Symbol,
		&i.TotalTransactions,
		&i.NetQuantity,
		&i.TotalInvested,
		&i.TotalReceived,
		&i.TotalFees,
	)
	return i, err
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT id, type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at
FROM transactions
WHERE date BETWEEN ? AND ?
ORDER BY date DESC, created_at DESC
`

type GetTransactionsByDateRangeParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByDateRange, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Symbol,
			&i.Quantity,
			&i.Price,
			&i.TotalAmount,
			&i.Fees,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsBySymbol = `-- name: GetTransactionsBySymbol :many
SELECT id, type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at
FROM transactions
WHERE symbol = ? COLLATE NOCASE
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetTransactionsBySymbol(ctx context.Context, symbol string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsBySymbol, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Symbol,
			&i.Quantity,
			&i.Price,
			&i.TotalAmount,
			&i.Fees,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByType = `-- name: GetTransactionsByType :many
SELECT id, type, symbol, quantity, price, total_amount, fees, date, notes, created_at, updated_at
FROM transactions
WHERE type = ?
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetTransactionsByType(ctx context.Context, type_ string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Symbol,
			&i.Quantity,
			&i.Price,
			&i.TotalAmount,
			&i.Fees,
			&i.Date,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE transactions 
SET type = ?, symbol = ?, quantity = ?, price = ?, total_amount = ?, fees = ?, date = ?, notes = ?, updated_at = ?
WHERE id = ?
`

type UpdateTransactionParams struct {
	Type        string          `json:"type"`
	Symbol      string          `json:"symbol"`
	Quantity    models.Quantity `json:"quantity"`
	Price       int64           `json:"price"`
	TotalAmount models.Money    `json:"total_amount"`
	Fees        models.Money    `json:"fees"`
	Date        time.Time       `json:"date"`
	Notes       sql.NullString  `json:"notes"`
	UpdatedAt   sql.NullTime    `json:"updated_at"`
	ID          int64           `json:"id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, updateTransaction,
		arg.Type,
		arg.Symbol,
		arg.Quantity,
		arg.Price,
		arg.TotalAmount,
		arg.Fees,
		arg.Date,
		arg.Notes,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
