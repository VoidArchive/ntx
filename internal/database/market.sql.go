// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: market.sql

package database

import (
	"context"
	"database/sql"
	"strings"

	"ntx/internal/data/models"
)

const cleanupStaleData = `-- name: CleanupStaleData :exec
DELETE FROM market_data 
WHERE timestamp < ?
`

func (q *Queries) CleanupStaleData(ctx context.Context, timestamp sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, cleanupStaleData, timestamp)
	return err
}

const deleteMarketData = `-- name: DeleteMarketData :exec
DELETE FROM market_data 
WHERE symbol = ? COLLATE NOCASE
`

func (q *Queries) DeleteMarketData(ctx context.Context, symbol string) error {
	_, err := q.db.ExecContext(ctx, deleteMarketData, symbol)
	return err
}

const getAllMarketData = `-- name: GetAllMarketData :many
SELECT id, symbol, last_price, change_amount, change_percent, volume, timestamp
FROM market_data m1
WHERE m1.timestamp = (
    SELECT MAX(m2.timestamp) 
    FROM market_data m2 
    WHERE m2.symbol = m1.symbol COLLATE NOCASE
)
ORDER BY symbol
`

func (q *Queries) GetAllMarketData(ctx context.Context) ([]MarketDatum, error) {
	rows, err := q.db.QueryContext(ctx, getAllMarketData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketDatum
	for rows.Next() {
		var i MarketDatum
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.LastPrice,
			&i.ChangeAmount,
			&i.ChangePercent,
			&i.Volume,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataAge = `-- name: GetDataAge :one
SELECT 
    symbol,
    CASE 
        WHEN MAX(timestamp) IS NULL THEN NULL
        ELSE (julianday('now') - julianday(MAX(timestamp))) * 24 * 60 * 60
    END as age_seconds
FROM market_data 
WHERE symbol = ? COLLATE NOCASE
`

type GetDataAgeRow struct {
	Symbol     string      `json:"symbol"`
	AgeSeconds interface{} `json:"age_seconds"`
}

func (q *Queries) GetDataAge(ctx context.Context, symbol string) (GetDataAgeRow, error) {
	row := q.db.QueryRowContext(ctx, getDataAge, symbol)
	var i GetDataAgeRow
	err := row.Scan(&i.Symbol, &i.AgeSeconds)
	return i, err
}

const getHistoricalPrices = `-- name: GetHistoricalPrices :many
SELECT id, symbol, last_price, change_amount, change_percent, volume, timestamp
FROM market_data
WHERE symbol = ? COLLATE NOCASE 
AND timestamp BETWEEN ? AND ?
ORDER BY timestamp DESC
`

func (q *Queries) GetHistoricalPrices(ctx context.Context, symbol string) ([]MarketDatum, error) {
	rows, err := q.db.QueryContext(ctx, getHistoricalPrices, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketDatum
	for rows.Next() {
		var i MarketDatum
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.LastPrice,
			&i.ChangeAmount,
			&i.ChangePercent,
			&i.Volume,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPrices = `-- name: GetLatestPrices :many
SELECT symbol, last_price
FROM market_data m1
WHERE m1.symbol IN (/*SLICE:symbols*/?) COLLATE NOCASE
AND m1.timestamp = (
    SELECT MAX(m2.timestamp) 
    FROM market_data m2 
    WHERE m2.symbol = m1.symbol COLLATE NOCASE
)
`

type GetLatestPricesRow struct {
	Symbol    string       `json:"symbol"`
	LastPrice models.Money `json:"last_price"`
}

func (q *Queries) GetLatestPrices(ctx context.Context, symbols []string) ([]GetLatestPricesRow, error) {
	query := getLatestPrices
	var queryParams []interface{}
	if len(symbols) > 0 {
		for _, v := range symbols {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:symbols*/?", strings.Repeat(",?", len(symbols))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:symbols*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPricesRow
	for rows.Next() {
		var i GetLatestPricesRow
		if err := rows.Scan(&i.Symbol, &i.LastPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarketData = `-- name: GetMarketData :one
SELECT id, symbol, last_price, change_amount, change_percent, volume, timestamp
FROM market_data
WHERE symbol = ? COLLATE NOCASE
ORDER BY timestamp DESC
LIMIT 1
`

func (q *Queries) GetMarketData(ctx context.Context, symbol string) (MarketDatum, error) {
	row := q.db.QueryRowContext(ctx, getMarketData, symbol)
	var i MarketDatum
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.LastPrice,
		&i.ChangeAmount,
		&i.ChangePercent,
		&i.Volume,
		&i.Timestamp,
	)
	return i, err
}

const getMarketDataBatch = `-- name: GetMarketDataBatch :many
SELECT id, symbol, last_price, change_amount, change_percent, volume, timestamp
FROM market_data m1
WHERE m1.symbol IN (/*SLICE:symbols*/?) COLLATE NOCASE
AND m1.timestamp = (
    SELECT MAX(m2.timestamp) 
    FROM market_data m2 
    WHERE m2.symbol = m1.symbol COLLATE NOCASE
)
`

func (q *Queries) GetMarketDataBatch(ctx context.Context, symbols []string) ([]MarketDatum, error) {
	query := getMarketDataBatch
	var queryParams []interface{}
	if len(symbols) > 0 {
		for _, v := range symbols {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:symbols*/?", strings.Repeat(",?", len(symbols))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:symbols*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketDatum
	for rows.Next() {
		var i MarketDatum
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.LastPrice,
			&i.ChangeAmount,
			&i.ChangePercent,
			&i.Volume,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMarketData = `-- name: UpsertMarketData :execresult

INSERT OR REPLACE INTO market_data (symbol, last_price, change_amount, change_percent, volume, timestamp)
VALUES (?, ?, ?, ?, ?, ?)
`

type UpsertMarketDataParams struct {
	Symbol        string        `json:"symbol"`
	LastPrice     models.Money  `json:"last_price"`
	ChangeAmount  models.Money  `json:"change_amount"`
	ChangePercent sql.NullInt64 `json:"change_percent"`
	Volume        sql.NullInt64 `json:"volume"`
	Timestamp     sql.NullTime  `json:"timestamp"`
}

// Market Data Operations
func (q *Queries) UpsertMarketData(ctx context.Context, arg UpsertMarketDataParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, upsertMarketData,
		arg.Symbol,
		arg.LastPrice,
		arg.ChangeAmount,
		arg.ChangePercent,
		arg.Volume,
		arg.Timestamp,
	)
}
