// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: portfolio.sql

package database

import (
	"context"
	"database/sql"

	"ntx/internal/data/models"
)

const createHolding = `-- name: CreateHolding :execresult

INSERT INTO portfolio (symbol, quantity, avg_cost, purchase_date, notes, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateHoldingParams struct {
	Symbol       string          `json:"symbol"`
	Quantity     models.Quantity `json:"quantity"`
	AvgCost      models.Money    `json:"avg_cost"`
	PurchaseDate sql.NullTime    `json:"purchase_date"`
	Notes        sql.NullString  `json:"notes"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
}

// Portfolio Operations
func (q *Queries) CreateHolding(ctx context.Context, arg CreateHoldingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createHolding,
		arg.Symbol,
		arg.Quantity,
		arg.AvgCost,
		arg.PurchaseDate,
		arg.Notes,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const deleteHolding = `-- name: DeleteHolding :exec
DELETE FROM portfolio WHERE id = ?
`

func (q *Queries) DeleteHolding(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteHolding, id)
	return err
}

const deleteHoldingBySymbol = `-- name: DeleteHoldingBySymbol :exec
DELETE FROM portfolio WHERE symbol = ? COLLATE NOCASE
`

func (q *Queries) DeleteHoldingBySymbol(ctx context.Context, symbol string) error {
	_, err := q.db.ExecContext(ctx, deleteHoldingBySymbol, symbol)
	return err
}

const getAllHoldings = `-- name: GetAllHoldings :many
SELECT id, symbol, quantity, avg_cost, purchase_date, notes, created_at, updated_at
FROM portfolio
ORDER BY symbol
`

func (q *Queries) GetAllHoldings(ctx context.Context) ([]Portfolio, error) {
	rows, err := q.db.QueryContext(ctx, getAllHoldings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Portfolio
	for rows.Next() {
		var i Portfolio
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Quantity,
			&i.AvgCost,
			&i.PurchaseDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolding = `-- name: GetHolding :one
SELECT id, symbol, quantity, avg_cost, purchase_date, notes, created_at, updated_at
FROM portfolio
WHERE id = ?
`

func (q *Queries) GetHolding(ctx context.Context, id int64) (Portfolio, error) {
	row := q.db.QueryRowContext(ctx, getHolding, id)
	var i Portfolio
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.Quantity,
		&i.AvgCost,
		&i.PurchaseDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHoldingBySymbol = `-- name: GetHoldingBySymbol :one
SELECT id, symbol, quantity, avg_cost, purchase_date, notes, created_at, updated_at
FROM portfolio
WHERE symbol = ? COLLATE NOCASE
`

func (q *Queries) GetHoldingBySymbol(ctx context.Context, symbol string) (Portfolio, error) {
	row := q.db.QueryRowContext(ctx, getHoldingBySymbol, symbol)
	var i Portfolio
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.Quantity,
		&i.AvgCost,
		&i.PurchaseDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHoldingsWithValues = `-- name: GetHoldingsWithValues :many
SELECT 
    p.id, p.symbol, p.quantity, p.avg_cost, p.purchase_date, p.notes, p.created_at, p.updated_at,
    COALESCE(m.last_price, 0) as current_price,
    (p.quantity * p.avg_cost) as total_cost,
    (p.quantity * COALESCE(m.last_price, p.avg_cost)) as current_value
FROM portfolio p
LEFT JOIN (
    SELECT symbol, last_price,
           ROW_NUMBER() OVER (PARTITION BY symbol ORDER BY timestamp DESC) as rn
    FROM market_data
) m ON p.symbol = m.symbol COLLATE NOCASE AND m.rn = 1
ORDER BY p.symbol
`

type GetHoldingsWithValuesRow struct {
	ID           int64           `json:"id"`
	Symbol       string          `json:"symbol"`
	Quantity     models.Quantity `json:"quantity"`
	AvgCost      models.Money    `json:"avg_cost"`
	PurchaseDate sql.NullTime    `json:"purchase_date"`
	Notes        sql.NullString  `json:"notes"`
	CreatedAt    sql.NullTime    `json:"created_at"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	CurrentPrice models.Money    `json:"current_price"`
	TotalCost    interface{}     `json:"total_cost"`
	CurrentValue interface{}     `json:"current_value"`
}

func (q *Queries) GetHoldingsWithValues(ctx context.Context) ([]GetHoldingsWithValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getHoldingsWithValues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoldingsWithValuesRow
	for rows.Next() {
		var i GetHoldingsWithValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Quantity,
			&i.AvgCost,
			&i.PurchaseDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentPrice,
			&i.TotalCost,
			&i.CurrentValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPortfolioSummary = `-- name: GetPortfolioSummary :one
SELECT 
    COUNT(*) as total_holdings,
    COALESCE(SUM(quantity * avg_cost), 0) as total_invested,
    COALESCE(SUM(quantity * COALESCE(m.last_price, avg_cost)), 0) as current_value
FROM portfolio p
LEFT JOIN (
    SELECT symbol, last_price,
           ROW_NUMBER() OVER (PARTITION BY symbol ORDER BY timestamp DESC) as rn
    FROM market_data
) m ON p.symbol = m.symbol COLLATE NOCASE AND m.rn = 1
`

type GetPortfolioSummaryRow struct {
	TotalHoldings int64       `json:"total_holdings"`
	TotalInvested interface{} `json:"total_invested"`
	CurrentValue  interface{} `json:"current_value"`
}

func (q *Queries) GetPortfolioSummary(ctx context.Context) (GetPortfolioSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getPortfolioSummary)
	var i GetPortfolioSummaryRow
	err := row.Scan(&i.TotalHoldings, &i.TotalInvested, &i.CurrentValue)
	return i, err
}

const getPortfolioValue = `-- name: GetPortfolioValue :one
SELECT COALESCE(SUM(quantity * avg_cost), 0) as total_value
FROM portfolio
`

func (q *Queries) GetPortfolioValue(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getPortfolioValue)
	var total_value interface{}
	err := row.Scan(&total_value)
	return total_value, err
}

const updateHolding = `-- name: UpdateHolding :exec
UPDATE portfolio
SET quantity = ?, avg_cost = ?, purchase_date = ?, notes = ?, updated_at = ?
WHERE id = ?
`

type UpdateHoldingParams struct {
	Quantity     models.Quantity `json:"quantity"`
	AvgCost      models.Money    `json:"avg_cost"`
	PurchaseDate sql.NullTime    `json:"purchase_date"`
	Notes        sql.NullString  `json:"notes"`
	UpdatedAt    sql.NullTime    `json:"updated_at"`
	ID           int64           `json:"id"`
}

func (q *Queries) UpdateHolding(ctx context.Context, arg UpdateHoldingParams) error {
	_, err := q.db.ExecContext(ctx, updateHolding,
		arg.Quantity,
		arg.AvgCost,
		arg.PurchaseDate,
		arg.Notes,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
