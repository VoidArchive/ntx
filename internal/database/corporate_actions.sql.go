// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: corporate_actions.sql

package database

import (
	"context"
	"database/sql"
	"strings"

	"ntx/internal/data/models"
)

const createCorporateAction = `-- name: CreateCorporateAction :execresult

INSERT INTO corporate_actions 
(symbol, action_type, announcement_date, record_date, ex_date, ratio, dividend_amount, processed, notes, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateCorporateActionParams struct {
	Symbol           string         `json:"symbol"`
	ActionType       string         `json:"action_type"`
	AnnouncementDate sql.NullTime   `json:"announcement_date"`
	RecordDate       sql.NullTime   `json:"record_date"`
	ExDate           sql.NullTime   `json:"ex_date"`
	Ratio            sql.NullString `json:"ratio"`
	DividendAmount   models.Money   `json:"dividend_amount"`
	Processed        sql.NullBool   `json:"processed"`
	Notes            sql.NullString `json:"notes"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

// Corporate Actions Operations
func (q *Queries) CreateCorporateAction(ctx context.Context, arg CreateCorporateActionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCorporateAction,
		arg.Symbol,
		arg.ActionType,
		arg.AnnouncementDate,
		arg.RecordDate,
		arg.ExDate,
		arg.Ratio,
		arg.DividendAmount,
		arg.Processed,
		arg.Notes,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const deleteCorporateAction = `-- name: DeleteCorporateAction :exec
DELETE FROM corporate_actions WHERE id = ?
`

func (q *Queries) DeleteCorporateAction(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCorporateAction, id)
	return err
}

const getAllCorporateActions = `-- name: GetAllCorporateActions :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
ORDER BY ex_date DESC, created_at DESC
`

func (q *Queries) GetAllCorporateActions(ctx context.Context) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getAllCorporateActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorporateAction = `-- name: GetCorporateAction :one
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE id = ?
`

func (q *Queries) GetCorporateAction(ctx context.Context, id int64) (CorporateAction, error) {
	row := q.db.QueryRowContext(ctx, getCorporateAction, id)
	var i CorporateAction
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.ActionType,
		&i.AnnouncementDate,
		&i.RecordDate,
		&i.ExDate,
		&i.Ratio,
		&i.DividendAmount,
		&i.Processed,
		&i.ProcessedDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCorporateActionsByDateRange = `-- name: GetCorporateActionsByDateRange :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE ex_date BETWEEN ? AND ?
ORDER BY ex_date DESC, created_at DESC
`

type GetCorporateActionsByDateRangeParams struct {
	FromExDate sql.NullTime `json:"from_ex_date"`
	ToExDate   sql.NullTime `json:"to_ex_date"`
}

func (q *Queries) GetCorporateActionsByDateRange(ctx context.Context, arg GetCorporateActionsByDateRangeParams) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getCorporateActionsByDateRange, arg.FromExDate, arg.ToExDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorporateActionsBySymbol = `-- name: GetCorporateActionsBySymbol :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE symbol = ? COLLATE NOCASE
ORDER BY ex_date DESC, created_at DESC
`

func (q *Queries) GetCorporateActionsBySymbol(ctx context.Context, symbol string) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getCorporateActionsBySymbol, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorporateActionsByType = `-- name: GetCorporateActionsByType :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE action_type = ?
ORDER BY ex_date DESC, created_at DESC
`

func (q *Queries) GetCorporateActionsByType(ctx context.Context, actionType string) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getCorporateActionsByType, actionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorporateActionsForPortfolio = `-- name: GetCorporateActionsForPortfolio :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE symbol IN (/*SLICE:symbols*/?) COLLATE NOCASE
ORDER BY symbol, ex_date DESC
`

func (q *Queries) GetCorporateActionsForPortfolio(ctx context.Context, symbols []string) ([]CorporateAction, error) {
	query := getCorporateActionsForPortfolio
	var queryParams []interface{}
	if len(symbols) > 0 {
		for _, v := range symbols {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:symbols*/?", strings.Repeat(",?", len(symbols))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:symbols*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDividendHistory = `-- name: GetDividendHistory :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE action_type = 'dividend' AND dividend_amount > 0
ORDER BY ex_date DESC, created_at DESC
`

func (q *Queries) GetDividendHistory(ctx context.Context) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getDividendHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCorporateActions = `-- name: GetPendingCorporateActions :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE processed = FALSE
ORDER BY ex_date ASC, created_at ASC
`

func (q *Queries) GetPendingCorporateActions(ctx context.Context) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCorporateActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingCorporateActions = `-- name: GetUpcomingCorporateActions :many
SELECT id, symbol, action_type, announcement_date, record_date, ex_date, ratio,
       dividend_amount, processed, processed_date, notes, created_at, updated_at
FROM corporate_actions
WHERE ex_date BETWEEN date('now') AND date('now', '+' || ? || ' days')
ORDER BY ex_date ASC, created_at ASC
`

func (q *Queries) GetUpcomingCorporateActions(ctx context.Context, dollar_1 sql.NullString) ([]CorporateAction, error) {
	rows, err := q.db.QueryContext(ctx, getUpcomingCorporateActions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CorporateAction
	for rows.Next() {
		var i CorporateAction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExDate,
			&i.Ratio,
			&i.DividendAmount,
			&i.Processed,
			&i.ProcessedDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAsProcessed = `-- name: MarkAsProcessed :exec
UPDATE corporate_actions
SET processed = TRUE, processed_date = ?, updated_at = ?
WHERE id = ?
`

type MarkAsProcessedParams struct {
	ProcessedDate sql.NullTime `json:"processed_date"`
	UpdatedAt     sql.NullTime `json:"updated_at"`
	ID            int64        `json:"id"`
}

func (q *Queries) MarkAsProcessed(ctx context.Context, arg MarkAsProcessedParams) error {
	_, err := q.db.ExecContext(ctx, markAsProcessed, arg.ProcessedDate, arg.UpdatedAt, arg.ID)
	return err
}

const updateCorporateAction = `-- name: UpdateCorporateAction :exec
UPDATE corporate_actions
SET action_type = ?, announcement_date = ?, record_date = ?, ex_date = ?,
    ratio = ?, dividend_amount = ?, processed = ?, processed_date = ?, notes = ?, updated_at = ?
WHERE id = ?
`

type UpdateCorporateActionParams struct {
	ActionType       string         `json:"action_type"`
	AnnouncementDate sql.NullTime   `json:"announcement_date"`
	RecordDate       sql.NullTime   `json:"record_date"`
	ExDate           sql.NullTime   `json:"ex_date"`
	Ratio            sql.NullString `json:"ratio"`
	DividendAmount   models.Money   `json:"dividend_amount"`
	Processed        sql.NullBool   `json:"processed"`
	ProcessedDate    sql.NullTime   `json:"processed_date"`
	Notes            sql.NullString `json:"notes"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateCorporateAction(ctx context.Context, arg UpdateCorporateActionParams) error {
	_, err := q.db.ExecContext(ctx, updateCorporateAction,
		arg.ActionType,
		arg.AnnouncementDate,
		arg.RecordDate,
		arg.ExDate,
		arg.Ratio,
		arg.DividendAmount,
		arg.Processed,
		arg.ProcessedDate,
		arg.Notes,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
