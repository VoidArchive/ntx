// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: corporate_actions.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createCorporateAction = `-- name: CreateCorporateAction :one
INSERT INTO corporate_actions (symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at
`

type CreateCorporateActionParams struct {
	Symbol           string         `json:"symbol"`
	ActionType       string         `json:"action_type"`
	AnnouncementDate time.Time      `json:"announcement_date"`
	RecordDate       time.Time      `json:"record_date"`
	ExecutionDate    sql.NullTime   `json:"execution_date"`
	RatioFrom        sql.NullInt64  `json:"ratio_from"`
	RatioTo          sql.NullInt64  `json:"ratio_to"`
	AmountPaisa      sql.NullInt64  `json:"amount_paisa"`
	Notes            sql.NullString `json:"notes"`
}

func (q *Queries) CreateCorporateAction(ctx context.Context, arg CreateCorporateActionParams) (CorporateActions, error) {
	row := q.db.QueryRowContext(ctx, createCorporateAction,
		arg.Symbol,
		arg.ActionType,
		arg.AnnouncementDate,
		arg.RecordDate,
		arg.ExecutionDate,
		arg.RatioFrom,
		arg.RatioTo,
		arg.AmountPaisa,
		arg.Notes,
	)
	var i CorporateActions
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.ActionType,
		&i.AnnouncementDate,
		&i.RecordDate,
		&i.ExecutionDate,
		&i.RatioFrom,
		&i.RatioTo,
		&i.AmountPaisa,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCorporateAction = `-- name: DeleteCorporateAction :exec
DELETE FROM corporate_actions WHERE id = ?
`

func (q *Queries) DeleteCorporateAction(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCorporateAction, id)
	return err
}

const getCorporateAction = `-- name: GetCorporateAction :one
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions WHERE id = ?
`

func (q *Queries) GetCorporateAction(ctx context.Context, id int64) (CorporateActions, error) {
	row := q.db.QueryRowContext(ctx, getCorporateAction, id)
	var i CorporateActions
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.ActionType,
		&i.AnnouncementDate,
		&i.RecordDate,
		&i.ExecutionDate,
		&i.RatioFrom,
		&i.RatioTo,
		&i.AmountPaisa,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getCorporateActionsBySymbolAndDate = `-- name: GetCorporateActionsBySymbolAndDate :many
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions 
WHERE symbol = ? AND record_date <= ? 
ORDER BY record_date DESC
`

type GetCorporateActionsBySymbolAndDateParams struct {
	Symbol     string    `json:"symbol"`
	RecordDate time.Time `json:"record_date"`
}

func (q *Queries) GetCorporateActionsBySymbolAndDate(ctx context.Context, arg GetCorporateActionsBySymbolAndDateParams) ([]CorporateActions, error) {
	rows, err := q.db.QueryContext(ctx, getCorporateActionsBySymbolAndDate, arg.Symbol, arg.RecordDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorporateActions{}
	for rows.Next() {
		var i CorporateActions
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExecutionDate,
			&i.RatioFrom,
			&i.RatioTo,
			&i.AmountPaisa,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCorporateActions = `-- name: GetPendingCorporateActions :many
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions 
WHERE execution_date IS NULL OR execution_date > date('now')
ORDER BY record_date ASC
`

func (q *Queries) GetPendingCorporateActions(ctx context.Context) ([]CorporateActions, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCorporateActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorporateActions{}
	for rows.Next() {
		var i CorporateActions
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExecutionDate,
			&i.RatioFrom,
			&i.RatioTo,
			&i.AmountPaisa,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporateActions = `-- name: ListCorporateActions :many
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions ORDER BY record_date DESC, created_at DESC
`

func (q *Queries) ListCorporateActions(ctx context.Context) ([]CorporateActions, error) {
	rows, err := q.db.QueryContext(ctx, listCorporateActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorporateActions{}
	for rows.Next() {
		var i CorporateActions
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExecutionDate,
			&i.RatioFrom,
			&i.RatioTo,
			&i.AmountPaisa,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporateActionsByDateRange = `-- name: ListCorporateActionsByDateRange :many
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions 
WHERE record_date BETWEEN ? AND ?
ORDER BY record_date DESC, created_at DESC
`

type ListCorporateActionsByDateRangeParams struct {
	FromRecordDate time.Time `json:"from_record_date"`
	ToRecordDate   time.Time `json:"to_record_date"`
}

func (q *Queries) ListCorporateActionsByDateRange(ctx context.Context, arg ListCorporateActionsByDateRangeParams) ([]CorporateActions, error) {
	rows, err := q.db.QueryContext(ctx, listCorporateActionsByDateRange, arg.FromRecordDate, arg.ToRecordDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorporateActions{}
	for rows.Next() {
		var i CorporateActions
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExecutionDate,
			&i.RatioFrom,
			&i.RatioTo,
			&i.AmountPaisa,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporateActionsBySymbol = `-- name: ListCorporateActionsBySymbol :many
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions 
WHERE symbol = ? 
ORDER BY record_date DESC, created_at DESC
`

func (q *Queries) ListCorporateActionsBySymbol(ctx context.Context, symbol string) ([]CorporateActions, error) {
	rows, err := q.db.QueryContext(ctx, listCorporateActionsBySymbol, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorporateActions{}
	for rows.Next() {
		var i CorporateActions
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExecutionDate,
			&i.RatioFrom,
			&i.RatioTo,
			&i.AmountPaisa,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporateActionsByType = `-- name: ListCorporateActionsByType :many
SELECT id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at FROM corporate_actions 
WHERE action_type = ? 
ORDER BY record_date DESC, created_at DESC
`

func (q *Queries) ListCorporateActionsByType(ctx context.Context, actionType string) ([]CorporateActions, error) {
	rows, err := q.db.QueryContext(ctx, listCorporateActionsByType, actionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorporateActions{}
	for rows.Next() {
		var i CorporateActions
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.ActionType,
			&i.AnnouncementDate,
			&i.RecordDate,
			&i.ExecutionDate,
			&i.RatioFrom,
			&i.RatioTo,
			&i.AmountPaisa,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCorporateAction = `-- name: UpdateCorporateAction :one
UPDATE corporate_actions 
SET symbol = ?, action_type = ?, announcement_date = ?, record_date = ?, 
    execution_date = ?, ratio_from = ?, ratio_to = ?, amount_paisa = ?, notes = ?
WHERE id = ?
RETURNING id, symbol, action_type, announcement_date, record_date, execution_date, ratio_from, ratio_to, amount_paisa, notes, created_at
`

type UpdateCorporateActionParams struct {
	Symbol           string         `json:"symbol"`
	ActionType       string         `json:"action_type"`
	AnnouncementDate time.Time      `json:"announcement_date"`
	RecordDate       time.Time      `json:"record_date"`
	ExecutionDate    sql.NullTime   `json:"execution_date"`
	RatioFrom        sql.NullInt64  `json:"ratio_from"`
	RatioTo          sql.NullInt64  `json:"ratio_to"`
	AmountPaisa      sql.NullInt64  `json:"amount_paisa"`
	Notes            sql.NullString `json:"notes"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateCorporateAction(ctx context.Context, arg UpdateCorporateActionParams) (CorporateActions, error) {
	row := q.db.QueryRowContext(ctx, updateCorporateAction,
		arg.Symbol,
		arg.ActionType,
		arg.AnnouncementDate,
		arg.RecordDate,
		arg.ExecutionDate,
		arg.RatioFrom,
		arg.RatioTo,
		arg.AmountPaisa,
		arg.Notes,
		arg.ID,
	)
	var i CorporateActions
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.ActionType,
		&i.AnnouncementDate,
		&i.RecordDate,
		&i.ExecutionDate,
		&i.RatioFrom,
		&i.RatioTo,
		&i.AmountPaisa,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
