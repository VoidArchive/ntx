// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: company.sql

package sqlc

import (
	"context"
)

const countCompanies = `-- name: CountCompanies :one
SELECT COUNT(*) FROM companies
`

func (q *Queries) CountCompanies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCompanies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCompany = `-- name: GetCompany :one
SELECT symbol, name, sector, description, logo_url, last_synced FROM companies WHERE symbol = ? LIMIT 1
`

func (q *Queries) GetCompany(ctx context.Context, symbol string) (Company, error) {
	row := q.db.QueryRowContext(ctx, getCompany, symbol)
	var i Company
	err := row.Scan(
		&i.Symbol,
		&i.Name,
		&i.Sector,
		&i.Description,
		&i.LogoUrl,
		&i.LastSynced,
	)
	return i, err
}

const listCompanies = `-- name: ListCompanies :many
SELECT symbol, name, sector, description, logo_url, last_synced FROM companies ORDER BY symbol
`

func (q *Queries) ListCompanies(ctx context.Context) ([]Company, error) {
	rows, err := q.db.QueryContext(ctx, listCompanies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.Symbol,
			&i.Name,
			&i.Sector,
			&i.Description,
			&i.LogoUrl,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompaniesBySector = `-- name: ListCompaniesBySector :many
SELECT symbol, name, sector, description, logo_url, last_synced FROM companies WHERE sector = ? ORDER BY symbol
`

func (q *Queries) ListCompaniesBySector(ctx context.Context, sector int64) ([]Company, error) {
	rows, err := q.db.QueryContext(ctx, listCompaniesBySector, sector)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.Symbol,
			&i.Name,
			&i.Sector,
			&i.Description,
			&i.LogoUrl,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompanies = `-- name: SearchCompanies :many
SELECT symbol, name, sector, description, logo_url, last_synced FROM companies
WHERE symbol LIKE ? OR name LIKE ?
ORDER BY symbol
LIMIT ?
`

type SearchCompaniesParams struct {
	Symbol string `json:"symbol"`
	Name   string `json:"name"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) SearchCompanies(ctx context.Context, arg SearchCompaniesParams) ([]Company, error) {
	rows, err := q.db.QueryContext(ctx, searchCompanies, arg.Symbol, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.Symbol,
			&i.Name,
			&i.Sector,
			&i.Description,
			&i.LogoUrl,
			&i.LastSynced,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompanyDescription = `-- name: UpdateCompanyDescription :exec
UPDATE companies SET description = ? WHERE symbol = ?
`

type UpdateCompanyDescriptionParams struct {
	Description string `json:"description"`
	Symbol      string `json:"symbol"`
}

func (q *Queries) UpdateCompanyDescription(ctx context.Context, arg UpdateCompanyDescriptionParams) error {
	_, err := q.db.ExecContext(ctx, updateCompanyDescription, arg.Description, arg.Symbol)
	return err
}

const upsertCompany = `-- name: UpsertCompany :exec
INSERT INTO companies (symbol, name, sector, description, logo_url, last_synced)
VALUES (?, ?, ?, ?, ?, datetime('now'))
ON CONFLICT(symbol) DO UPDATE SET
    name = excluded.name,
    sector = excluded.sector,
    description = excluded.description,
    logo_url = excluded.logo_url,
    last_synced = excluded.last_synced
`

type UpsertCompanyParams struct {
	Symbol      string `json:"symbol"`
	Name        string `json:"name"`
	Sector      int64  `json:"sector"`
	Description string `json:"description"`
	LogoUrl     string `json:"logo_url"`
}

func (q *Queries) UpsertCompany(ctx context.Context, arg UpsertCompanyParams) error {
	_, err := q.db.ExecContext(ctx, upsertCompany,
		arg.Symbol,
		arg.Name,
		arg.Sector,
		arg.Description,
		arg.LogoUrl,
	)
	return err
}
