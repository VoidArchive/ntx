// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: screener.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getScreenerData = `-- name: GetScreenerData :many
SELECT
    c.symbol,
    c.name,
    c.sector,
    c.description,
    c.logo_url,
    p.date as price_date,
    p.open,
    p.high,
    p.low,
    p.close,
    p.previous_close,
    p.volume,
    p.turnover,
    f.pe,
    f.pb,
    f.eps,
    f.book_value,
    f.market_cap,
    f.dividend_yield,
    f.roe,
    f.shares_outstanding
FROM companies c
LEFT JOIN (
    SELECT p1.symbol, p1.date, p1.open, p1.high, p1.low, p1.close, p1.previous_close, p1.volume, p1.turnover, p1.is_complete
    FROM prices p1
    INNER JOIN (
        SELECT symbol, MAX(date) as max_date
        FROM prices
        GROUP BY symbol
    ) p2 ON p1.symbol = p2.symbol AND p1.date = p2.max_date
) p ON c.symbol = p.symbol
LEFT JOIN fundamentals f ON c.symbol = f.symbol
ORDER BY c.symbol
`

type GetScreenerDataRow struct {
	Symbol            string          `json:"symbol"`
	Name              string          `json:"name"`
	Sector            int64           `json:"sector"`
	Description       string          `json:"description"`
	LogoUrl           string          `json:"logo_url"`
	PriceDate         string          `json:"price_date"`
	Open              float64         `json:"open"`
	High              float64         `json:"high"`
	Low               float64         `json:"low"`
	Close             float64         `json:"close"`
	PreviousClose     sql.NullFloat64 `json:"previous_close"`
	Volume            int64           `json:"volume"`
	Turnover          sql.NullInt64   `json:"turnover"`
	Pe                sql.NullFloat64 `json:"pe"`
	Pb                sql.NullFloat64 `json:"pb"`
	Eps               sql.NullFloat64 `json:"eps"`
	BookValue         sql.NullFloat64 `json:"book_value"`
	MarketCap         sql.NullFloat64 `json:"market_cap"`
	DividendYield     sql.NullFloat64 `json:"dividend_yield"`
	Roe               sql.NullFloat64 `json:"roe"`
	SharesOutstanding sql.NullInt64   `json:"shares_outstanding"`
}

// Returns all data needed for screening: company + latest price + fundamentals
// Filtering and sorting will be done in Go for flexibility
func (q *Queries) GetScreenerData(ctx context.Context) ([]GetScreenerDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getScreenerData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScreenerDataRow
	for rows.Next() {
		var i GetScreenerDataRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Name,
			&i.Sector,
			&i.Description,
			&i.LogoUrl,
			&i.PriceDate,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.Pe,
			&i.Pb,
			&i.Eps,
			&i.BookValue,
			&i.MarketCap,
			&i.DividendYield,
			&i.Roe,
			&i.SharesOutstanding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScreenerDataBySector = `-- name: GetScreenerDataBySector :many
SELECT
    c.symbol,
    c.name,
    c.sector,
    c.description,
    c.logo_url,
    p.date as price_date,
    p.open,
    p.high,
    p.low,
    p.close,
    p.previous_close,
    p.volume,
    p.turnover,
    f.pe,
    f.pb,
    f.eps,
    f.book_value,
    f.market_cap,
    f.dividend_yield,
    f.roe,
    f.shares_outstanding
FROM companies c
LEFT JOIN (
    SELECT p1.symbol, p1.date, p1.open, p1.high, p1.low, p1.close, p1.previous_close, p1.volume, p1.turnover, p1.is_complete
    FROM prices p1
    INNER JOIN (
        SELECT symbol, MAX(date) as max_date
        FROM prices
        GROUP BY symbol
    ) p2 ON p1.symbol = p2.symbol AND p1.date = p2.max_date
) p ON c.symbol = p.symbol
LEFT JOIN fundamentals f ON c.symbol = f.symbol
WHERE c.sector = ?
ORDER BY c.symbol
`

type GetScreenerDataBySectorRow struct {
	Symbol            string          `json:"symbol"`
	Name              string          `json:"name"`
	Sector            int64           `json:"sector"`
	Description       string          `json:"description"`
	LogoUrl           string          `json:"logo_url"`
	PriceDate         string          `json:"price_date"`
	Open              float64         `json:"open"`
	High              float64         `json:"high"`
	Low               float64         `json:"low"`
	Close             float64         `json:"close"`
	PreviousClose     sql.NullFloat64 `json:"previous_close"`
	Volume            int64           `json:"volume"`
	Turnover          sql.NullInt64   `json:"turnover"`
	Pe                sql.NullFloat64 `json:"pe"`
	Pb                sql.NullFloat64 `json:"pb"`
	Eps               sql.NullFloat64 `json:"eps"`
	BookValue         sql.NullFloat64 `json:"book_value"`
	MarketCap         sql.NullFloat64 `json:"market_cap"`
	DividendYield     sql.NullFloat64 `json:"dividend_yield"`
	Roe               sql.NullFloat64 `json:"roe"`
	SharesOutstanding sql.NullInt64   `json:"shares_outstanding"`
}

func (q *Queries) GetScreenerDataBySector(ctx context.Context, sector int64) ([]GetScreenerDataBySectorRow, error) {
	rows, err := q.db.QueryContext(ctx, getScreenerDataBySector, sector)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScreenerDataBySectorRow
	for rows.Next() {
		var i GetScreenerDataBySectorRow
		if err := rows.Scan(
			&i.Symbol,
			&i.Name,
			&i.Sector,
			&i.Description,
			&i.LogoUrl,
			&i.PriceDate,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.Pe,
			&i.Pb,
			&i.Eps,
			&i.BookValue,
			&i.MarketCap,
			&i.DividendYield,
			&i.Roe,
			&i.SharesOutstanding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
