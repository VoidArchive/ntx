// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transaction.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM transactions
`

func (q *Queries) CountTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransactionsFiltered = `-- name: CountTransactionsFiltered :one
SELECT COUNT(*) FROM transactions
WHERE (? = '' OR symbol = ?)
  AND (? = 0 OR type = ?)
`

type CountTransactionsFilteredParams struct {
	Column1 interface{} `json:"column_1"`
	Symbol  string      `json:"symbol"`
	Column3 interface{} `json:"column_3"`
	Type    int64       `json:"type"`
}

func (q *Queries) CountTransactionsFiltered(ctx context.Context, arg CountTransactionsFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransactionsFiltered,
		arg.Column1,
		arg.Symbol,
		arg.Column3,
		arg.Type,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (id, symbol, type, quantity, price_paisa, total_paisa, date, description)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTransactionParams struct {
	ID          string         `json:"id"`
	Symbol      string         `json:"symbol"`
	Type        int64          `json:"type"`
	Quantity    float64        `json:"quantity"`
	PricePaisa  int64          `json:"price_paisa"`
	TotalPaisa  int64          `json:"total_paisa"`
	Date        string         `json:"date"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.ID,
		arg.Symbol,
		arg.Type,
		arg.Quantity,
		arg.PricePaisa,
		arg.TotalPaisa,
		arg.Date,
		arg.Description,
	)
	return err
}

const deleteAllTransactions = `-- name: DeleteAllTransactions :exec
DELETE FROM transactions
`

func (q *Queries) DeleteAllTransactions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllTransactions)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, symbol, type, quantity, price_paisa, total_paisa, date, description, created_at FROM transactions WHERE id = ? LIMIT 1
`

func (q *Queries) GetTransaction(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.Type,
		&i.Quantity,
		&i.PricePaisa,
		&i.TotalPaisa,
		&i.Date,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, symbol, type, quantity, price_paisa, total_paisa, date, description, created_at FROM transactions
ORDER BY date DESC
LIMIT ? OFFSET ?
`

type ListTransactionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Type,
			&i.Quantity,
			&i.PricePaisa,
			&i.TotalPaisa,
			&i.Date,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsBySymbol = `-- name: ListTransactionsBySymbol :many
SELECT id, symbol, type, quantity, price_paisa, total_paisa, date, description, created_at FROM transactions
WHERE symbol = ?
ORDER BY date DESC
`

func (q *Queries) ListTransactionsBySymbol(ctx context.Context, symbol string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsBySymbol, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Type,
			&i.Quantity,
			&i.PricePaisa,
			&i.TotalPaisa,
			&i.Date,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsBySymbolChronological = `-- name: ListTransactionsBySymbolChronological :many
SELECT id, symbol, type, quantity, price_paisa, total_paisa, date, description, created_at FROM transactions
WHERE symbol = ?
ORDER BY date ASC, created_at ASC
`

func (q *Queries) ListTransactionsBySymbolChronological(ctx context.Context, symbol string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsBySymbolChronological, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Type,
			&i.Quantity,
			&i.PricePaisa,
			&i.TotalPaisa,
			&i.Date,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsFiltered = `-- name: ListTransactionsFiltered :many
SELECT id, symbol, type, quantity, price_paisa, total_paisa, date, description, created_at FROM transactions
WHERE (? = '' OR symbol = ?)
  AND (? = 0 OR type = ?)
ORDER BY date DESC
LIMIT ? OFFSET ?
`

type ListTransactionsFilteredParams struct {
	Column1 interface{} `json:"column_1"`
	Symbol  string      `json:"symbol"`
	Column3 interface{} `json:"column_3"`
	Type    int64       `json:"type"`
	Limit   int64       `json:"limit"`
	Offset  int64       `json:"offset"`
}

func (q *Queries) ListTransactionsFiltered(ctx context.Context, arg ListTransactionsFilteredParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsFiltered,
		arg.Column1,
		arg.Symbol,
		arg.Column3,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Type,
			&i.Quantity,
			&i.PricePaisa,
			&i.TotalPaisa,
			&i.Date,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsWithoutPrices = `-- name: ListTransactionsWithoutPrices :many
SELECT id, symbol, type, quantity, price_paisa, total_paisa, date, description, created_at FROM transactions
WHERE total_paisa = 0
  AND type IN (1, 2)  -- BUY and SELL only
ORDER BY date ASC
`

func (q *Queries) ListTransactionsWithoutPrices(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsWithoutPrices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Type,
			&i.Quantity,
			&i.PricePaisa,
			&i.TotalPaisa,
			&i.Date,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transactionExists = `-- name: TransactionExists :one
SELECT EXISTS(
    SELECT 1 FROM transactions
    WHERE symbol = ? AND date = ? AND description = ?
) AS exists_flag
`

type TransactionExistsParams struct {
	Symbol      string         `json:"symbol"`
	Date        string         `json:"date"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) TransactionExists(ctx context.Context, arg TransactionExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, transactionExists, arg.Symbol, arg.Date, arg.Description)
	var exists_flag int64
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const updateTransactionPrices = `-- name: UpdateTransactionPrices :execrows
UPDATE transactions
SET price_paisa = ?,
    total_paisa = ?
WHERE symbol = ?
  AND type = ?
  AND quantity = ?
  AND total_paisa = 0
`

type UpdateTransactionPricesParams struct {
	PricePaisa int64   `json:"price_paisa"`
	TotalPaisa int64   `json:"total_paisa"`
	Symbol     string  `json:"symbol"`
	Type       int64   `json:"type"`
	Quantity   float64 `json:"quantity"`
}

func (q *Queries) UpdateTransactionPrices(ctx context.Context, arg UpdateTransactionPricesParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTransactionPrices,
		arg.PricePaisa,
		arg.TotalPaisa,
		arg.Symbol,
		arg.Type,
		arg.Quantity,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
