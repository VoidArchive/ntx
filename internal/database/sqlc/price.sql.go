// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: price.sql

package sqlc

import (
	"context"
	"database/sql"
)

const get52WeekHighLow = `-- name: Get52WeekHighLow :one
SELECT
    MAX(high) as week_52_high,
    MIN(low) as week_52_low
FROM prices
WHERE symbol = ?
  AND date >= date('now', '-52 weeks')
`

type Get52WeekHighLowRow struct {
	Week52High interface{} `json:"week_52_high"`
	Week52Low  interface{} `json:"week_52_low"`
}

func (q *Queries) Get52WeekHighLow(ctx context.Context, symbol string) (Get52WeekHighLowRow, error) {
	row := q.db.QueryRowContext(ctx, get52WeekHighLow, symbol)
	var i Get52WeekHighLowRow
	err := row.Scan(&i.Week52High, &i.Week52Low)
	return i, err
}

const getLatestPrice = `-- name: GetLatestPrice :one
SELECT symbol, date, open, high, low, close, previous_close, volume, turnover, is_complete FROM prices
WHERE symbol = ?
ORDER BY date DESC
LIMIT 1
`

func (q *Queries) GetLatestPrice(ctx context.Context, symbol string) (Price, error) {
	row := q.db.QueryRowContext(ctx, getLatestPrice, symbol)
	var i Price
	err := row.Scan(
		&i.Symbol,
		&i.Date,
		&i.Open,
		&i.High,
		&i.Low,
		&i.Close,
		&i.PreviousClose,
		&i.Volume,
		&i.Turnover,
		&i.IsComplete,
	)
	return i, err
}

const getPriceHistory = `-- name: GetPriceHistory :many
SELECT symbol, date, open, high, low, close, previous_close, volume, turnover, is_complete FROM prices
WHERE symbol = ?
  AND date >= ?
  AND date <= ?
ORDER BY date ASC
`

type GetPriceHistoryParams struct {
	Symbol string `json:"symbol"`
	Date   string `json:"date"`
	Date_2 string `json:"date_2"`
}

func (q *Queries) GetPriceHistory(ctx context.Context, arg GetPriceHistoryParams) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getPriceHistory, arg.Symbol, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.Symbol,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricesForDate = `-- name: GetPricesForDate :many
SELECT symbol, date, open, high, low, close, previous_close, volume, turnover, is_complete FROM prices
WHERE date = ?
ORDER BY symbol
`

func (q *Queries) GetPricesForDate(ctx context.Context, date string) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getPricesForDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.Symbol,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopGainers = `-- name: GetTopGainers :many
SELECT p.symbol, p.date, p.open, p.high, p.low, p.close, p.previous_close, p.volume, p.turnover, p.is_complete FROM prices p
INNER JOIN (
    SELECT symbol, MAX(date) as max_date
    FROM prices
    GROUP BY symbol
) latest ON p.symbol = latest.symbol AND p.date = latest.max_date
WHERE p.previous_close IS NOT NULL AND p.close > p.previous_close
ORDER BY ((p.close - p.previous_close) / p.previous_close) DESC
LIMIT ?
`

func (q *Queries) GetTopGainers(ctx context.Context, limit int64) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getTopGainers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.Symbol,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopGainersBySector = `-- name: GetTopGainersBySector :many
SELECT p.symbol, p.date, p.open, p.high, p.low, p.close, p.previous_close, p.volume, p.turnover, p.is_complete FROM prices p
INNER JOIN companies c ON p.symbol = c.symbol
INNER JOIN (
    SELECT symbol, MAX(date) as max_date
    FROM prices
    GROUP BY symbol
) latest ON p.symbol = latest.symbol AND p.date = latest.max_date
WHERE c.sector = ? AND p.previous_close IS NOT NULL AND p.close > p.previous_close
ORDER BY ((p.close - p.previous_close) / p.previous_close) DESC
LIMIT ?
`

type GetTopGainersBySectorParams struct {
	Sector int64 `json:"sector"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) GetTopGainersBySector(ctx context.Context, arg GetTopGainersBySectorParams) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getTopGainersBySector, arg.Sector, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.Symbol,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopLosers = `-- name: GetTopLosers :many
SELECT p.symbol, p.date, p.open, p.high, p.low, p.close, p.previous_close, p.volume, p.turnover, p.is_complete FROM prices p
INNER JOIN (
    SELECT symbol, MAX(date) as max_date
    FROM prices
    GROUP BY symbol
) latest ON p.symbol = latest.symbol AND p.date = latest.max_date
WHERE p.previous_close IS NOT NULL AND p.close < p.previous_close
ORDER BY ((p.close - p.previous_close) / p.previous_close) ASC
LIMIT ?
`

func (q *Queries) GetTopLosers(ctx context.Context, limit int64) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getTopLosers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.Symbol,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopLosersBySector = `-- name: GetTopLosersBySector :many
SELECT p.symbol, p.date, p.open, p.high, p.low, p.close, p.previous_close, p.volume, p.turnover, p.is_complete FROM prices p
INNER JOIN companies c ON p.symbol = c.symbol
INNER JOIN (
    SELECT symbol, MAX(date) as max_date
    FROM prices
    GROUP BY symbol
) latest ON p.symbol = latest.symbol AND p.date = latest.max_date
WHERE c.sector = ? AND p.previous_close IS NOT NULL AND p.close < p.previous_close
ORDER BY ((p.close - p.previous_close) / p.previous_close) ASC
LIMIT ?
`

type GetTopLosersBySectorParams struct {
	Sector int64 `json:"sector"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) GetTopLosersBySector(ctx context.Context, arg GetTopLosersBySectorParams) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getTopLosersBySector, arg.Sector, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.Symbol,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Close,
			&i.PreviousClose,
			&i.Volume,
			&i.Turnover,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPricesComplete = `-- name: MarkPricesComplete :exec
UPDATE prices SET is_complete = 1 WHERE date = ?
`

func (q *Queries) MarkPricesComplete(ctx context.Context, date string) error {
	_, err := q.db.ExecContext(ctx, markPricesComplete, date)
	return err
}

const upsertPrice = `-- name: UpsertPrice :exec
INSERT INTO prices (symbol, date, open, high, low, close, previous_close, volume, turnover, is_complete)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(symbol, date) DO UPDATE SET
    open = excluded.open,
    high = excluded.high,
    low = excluded.low,
    close = excluded.close,
    previous_close = excluded.previous_close,
    volume = excluded.volume,
    turnover = excluded.turnover,
    is_complete = excluded.is_complete
`

type UpsertPriceParams struct {
	Symbol        string          `json:"symbol"`
	Date          string          `json:"date"`
	Open          float64         `json:"open"`
	High          float64         `json:"high"`
	Low           float64         `json:"low"`
	Close         float64         `json:"close"`
	PreviousClose sql.NullFloat64 `json:"previous_close"`
	Volume        int64           `json:"volume"`
	Turnover      sql.NullInt64   `json:"turnover"`
	IsComplete    int64           `json:"is_complete"`
}

func (q *Queries) UpsertPrice(ctx context.Context, arg UpsertPriceParams) error {
	_, err := q.db.ExecContext(ctx, upsertPrice,
		arg.Symbol,
		arg.Date,
		arg.Open,
		arg.High,
		arg.Low,
		arg.Close,
		arg.PreviousClose,
		arg.Volume,
		arg.Turnover,
		arg.IsComplete,
	)
	return err
}
