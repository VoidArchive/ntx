// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: holding.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteHolding = `-- name: DeleteHolding :exec
DELETE FROM holdings WHERE symbol = ?
`

func (q *Queries) DeleteHolding(ctx context.Context, symbol string) error {
	_, err := q.db.ExecContext(ctx, deleteHolding, symbol)
	return err
}

const getHolding = `-- name: GetHolding :one
SELECT symbol, quantity, average_cost_paisa, total_cost_paisa, current_price_paisa, current_value_paisa, unrealized_pnl_paisa, unrealized_pnl_percent, last_updated, realized_pnl_paisa FROM holdings WHERE symbol = ? LIMIT 1
`

func (q *Queries) GetHolding(ctx context.Context, symbol string) (Holding, error) {
	row := q.db.QueryRowContext(ctx, getHolding, symbol)
	var i Holding
	err := row.Scan(
		&i.Symbol,
		&i.Quantity,
		&i.AverageCostPaisa,
		&i.TotalCostPaisa,
		&i.CurrentPricePaisa,
		&i.CurrentValuePaisa,
		&i.UnrealizedPnlPaisa,
		&i.UnrealizedPnlPercent,
		&i.LastUpdated,
		&i.RealizedPnlPaisa,
	)
	return i, err
}

const listHoldings = `-- name: ListHoldings :many
SELECT symbol, quantity, average_cost_paisa, total_cost_paisa, current_price_paisa, current_value_paisa, unrealized_pnl_paisa, unrealized_pnl_percent, last_updated, realized_pnl_paisa FROM holdings ORDER BY symbol
`

func (q *Queries) ListHoldings(ctx context.Context) ([]Holding, error) {
	rows, err := q.db.QueryContext(ctx, listHoldings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Holding
	for rows.Next() {
		var i Holding
		if err := rows.Scan(
			&i.Symbol,
			&i.Quantity,
			&i.AverageCostPaisa,
			&i.TotalCostPaisa,
			&i.CurrentPricePaisa,
			&i.CurrentValuePaisa,
			&i.UnrealizedPnlPaisa,
			&i.UnrealizedPnlPercent,
			&i.LastUpdated,
			&i.RealizedPnlPaisa,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHoldingCosts = `-- name: UpdateHoldingCosts :exec
UPDATE holdings
SET average_cost_paisa = ?,
    total_cost_paisa = ?,
    last_updated = datetime('now')
WHERE symbol = ?
`

type UpdateHoldingCostsParams struct {
	AverageCostPaisa int64  `json:"average_cost_paisa"`
	TotalCostPaisa   int64  `json:"total_cost_paisa"`
	Symbol           string `json:"symbol"`
}

func (q *Queries) UpdateHoldingCosts(ctx context.Context, arg UpdateHoldingCostsParams) error {
	_, err := q.db.ExecContext(ctx, updateHoldingCosts, arg.AverageCostPaisa, arg.TotalCostPaisa, arg.Symbol)
	return err
}

const updateHoldingPrices = `-- name: UpdateHoldingPrices :exec
UPDATE holdings
SET current_price_paisa = ?,
    current_value_paisa = ?,
    unrealized_pnl_paisa = ?,
    unrealized_pnl_percent = ?,
    last_updated = datetime('now')
WHERE symbol = ?
`

type UpdateHoldingPricesParams struct {
	CurrentPricePaisa    sql.NullInt64   `json:"current_price_paisa"`
	CurrentValuePaisa    sql.NullInt64   `json:"current_value_paisa"`
	UnrealizedPnlPaisa   sql.NullInt64   `json:"unrealized_pnl_paisa"`
	UnrealizedPnlPercent sql.NullFloat64 `json:"unrealized_pnl_percent"`
	Symbol               string          `json:"symbol"`
}

func (q *Queries) UpdateHoldingPrices(ctx context.Context, arg UpdateHoldingPricesParams) error {
	_, err := q.db.ExecContext(ctx, updateHoldingPrices,
		arg.CurrentPricePaisa,
		arg.CurrentValuePaisa,
		arg.UnrealizedPnlPaisa,
		arg.UnrealizedPnlPercent,
		arg.Symbol,
	)
	return err
}

const upsertHolding = `-- name: UpsertHolding :exec
INSERT INTO holdings (symbol, quantity, average_cost_paisa, total_cost_paisa, realized_pnl_paisa, last_updated)
VALUES (?, ?, ?, ?, ?, datetime('now'))
ON CONFLICT(symbol) DO UPDATE SET
    quantity = excluded.quantity,
    average_cost_paisa = excluded.average_cost_paisa,
    total_cost_paisa = excluded.total_cost_paisa,
    realized_pnl_paisa = excluded.realized_pnl_paisa,
    last_updated = excluded.last_updated
`

type UpsertHoldingParams struct {
	Symbol           string  `json:"symbol"`
	Quantity         float64 `json:"quantity"`
	AverageCostPaisa int64   `json:"average_cost_paisa"`
	TotalCostPaisa   int64   `json:"total_cost_paisa"`
	RealizedPnlPaisa int64   `json:"realized_pnl_paisa"`
}

func (q *Queries) UpsertHolding(ctx context.Context, arg UpsertHoldingParams) error {
	_, err := q.db.ExecContext(ctx, upsertHolding,
		arg.Symbol,
		arg.Quantity,
		arg.AverageCostPaisa,
		arg.TotalCostPaisa,
		arg.RealizedPnlPaisa,
	)
	return err
}
