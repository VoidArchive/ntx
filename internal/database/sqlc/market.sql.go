// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: market.sql

package sqlc

import (
	"context"
)

const getSectorSummary = `-- name: GetSectorSummary :many
SELECT
    c.sector,
    COUNT(*) as stock_count,
    COALESCE(SUM(p.turnover), 0) as turnover,
    COALESCE(SUM(CASE WHEN p.close > p.previous_close THEN 1 ELSE 0 END), 0) as gainers,
    COALESCE(SUM(CASE WHEN p.close < p.previous_close THEN 1 ELSE 0 END), 0) as losers
FROM companies c
LEFT JOIN (
    SELECT p1.symbol, p1.date, p1.open, p1.high, p1.low, p1.close, p1.previous_close, p1.volume, p1.turnover, p1.is_complete, p1.week_52_high, p1.week_52_low
    FROM prices p1
    INNER JOIN (
        SELECT symbol, MAX(date) as max_date
        FROM prices
        GROUP BY symbol
    ) p2 ON p1.symbol = p2.symbol AND p1.date = p2.max_date
) p ON c.symbol = p.symbol
GROUP BY c.sector
ORDER BY c.sector
`

type GetSectorSummaryRow struct {
	Sector     int64       `json:"sector"`
	StockCount int64       `json:"stock_count"`
	Turnover   interface{} `json:"turnover"`
	Gainers    interface{} `json:"gainers"`
	Losers     interface{} `json:"losers"`
}

// Returns aggregated sector-level data for ListSectors endpoint
func (q *Queries) GetSectorSummary(ctx context.Context) ([]GetSectorSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectorSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectorSummaryRow
	for rows.Next() {
		var i GetSectorSummaryRow
		if err := rows.Scan(
			&i.Sector,
			&i.StockCount,
			&i.Turnover,
			&i.Gainers,
			&i.Losers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
