// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: fundamentals.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getFundamentals = `-- name: GetFundamentals :one
SELECT symbol, pe, pb, eps, book_value, market_cap, dividend_yield, roe, shares_outstanding, updated_at FROM fundamentals WHERE symbol = ? LIMIT 1
`

func (q *Queries) GetFundamentals(ctx context.Context, symbol string) (Fundamental, error) {
	row := q.db.QueryRowContext(ctx, getFundamentals, symbol)
	var i Fundamental
	err := row.Scan(
		&i.Symbol,
		&i.Pe,
		&i.Pb,
		&i.Eps,
		&i.BookValue,
		&i.MarketCap,
		&i.DividendYield,
		&i.Roe,
		&i.SharesOutstanding,
		&i.UpdatedAt,
	)
	return i, err
}

const listFundamentals = `-- name: ListFundamentals :many
SELECT symbol, pe, pb, eps, book_value, market_cap, dividend_yield, roe, shares_outstanding, updated_at FROM fundamentals ORDER BY symbol
`

func (q *Queries) ListFundamentals(ctx context.Context) ([]Fundamental, error) {
	rows, err := q.db.QueryContext(ctx, listFundamentals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fundamental
	for rows.Next() {
		var i Fundamental
		if err := rows.Scan(
			&i.Symbol,
			&i.Pe,
			&i.Pb,
			&i.Eps,
			&i.BookValue,
			&i.MarketCap,
			&i.DividendYield,
			&i.Roe,
			&i.SharesOutstanding,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFundamentals = `-- name: UpsertFundamentals :exec
INSERT INTO fundamentals (symbol, pe, pb, eps, book_value, market_cap, dividend_yield, roe, shares_outstanding, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
ON CONFLICT(symbol) DO UPDATE SET
    pe = excluded.pe,
    pb = excluded.pb,
    eps = excluded.eps,
    book_value = excluded.book_value,
    market_cap = excluded.market_cap,
    dividend_yield = excluded.dividend_yield,
    roe = excluded.roe,
    shares_outstanding = excluded.shares_outstanding,
    updated_at = excluded.updated_at
`

type UpsertFundamentalsParams struct {
	Symbol            string          `json:"symbol"`
	Pe                sql.NullFloat64 `json:"pe"`
	Pb                sql.NullFloat64 `json:"pb"`
	Eps               sql.NullFloat64 `json:"eps"`
	BookValue         sql.NullFloat64 `json:"book_value"`
	MarketCap         sql.NullFloat64 `json:"market_cap"`
	DividendYield     sql.NullFloat64 `json:"dividend_yield"`
	Roe               sql.NullFloat64 `json:"roe"`
	SharesOutstanding sql.NullInt64   `json:"shares_outstanding"`
}

func (q *Queries) UpsertFundamentals(ctx context.Context, arg UpsertFundamentalsParams) error {
	_, err := q.db.ExecContext(ctx, upsertFundamentals,
		arg.Symbol,
		arg.Pe,
		arg.Pb,
		arg.Eps,
		arg.BookValue,
		arg.MarketCap,
		arg.DividendYield,
		arg.Roe,
		arg.SharesOutstanding,
	)
	return err
}
