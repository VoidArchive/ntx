// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (scrip, date, quantity, price, transaction_type, description)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, scrip, date, quantity, price, transaction_type, description, created_at
`

type CreateTransactionParams struct {
	Scrip           string
	Date            string
	Quantity        int64
	Price           sql.NullInt64
	TransactionType string
	Description     sql.NullString
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.Scrip,
		arg.Date,
		arg.Quantity,
		arg.Price,
		arg.TransactionType,
		arg.Description,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Scrip,
		&i.Date,
		&i.Quantity,
		&i.Price,
		&i.TransactionType,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getAllTransactions = `-- name: GetAllTransactions :many
SELECT id, scrip, date, quantity, price, transaction_type, description, created_at FROM transactions 
ORDER BY date ASC, id ASC
`

func (q *Queries) GetAllTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getAllTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Scrip,
			&i.Date,
			&i.Quantity,
			&i.Price,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionById = `-- name: GetTransactionById :one
SELECT id, scrip, date, quantity, price, transaction_type, description, created_at FROM transactions 
WHERE id = ?
`

func (q *Queries) GetTransactionById(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionById, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Scrip,
		&i.Date,
		&i.Quantity,
		&i.Price,
		&i.TransactionType,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT id, scrip, date, quantity, price, transaction_type, description, created_at FROM transactions 
WHERE date BETWEEN ? AND ?
ORDER BY date ASC, id ASC
`

type GetTransactionsByDateRangeParams struct {
	FromDate string
	ToDate   string
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByDateRange, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Scrip,
			&i.Date,
			&i.Quantity,
			&i.Price,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByScripOrderedByDate = `-- name: GetTransactionsByScripOrderedByDate :many
SELECT id, scrip, date, quantity, price, transaction_type, description, created_at FROM transactions 
WHERE scrip = ? 
ORDER BY date ASC, id ASC
`

func (q *Queries) GetTransactionsByScripOrderedByDate(ctx context.Context, scrip string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByScripOrderedByDate, scrip)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Scrip,
			&i.Date,
			&i.Quantity,
			&i.Price,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsWithoutPrice = `-- name: GetTransactionsWithoutPrice :many
SELECT id, scrip, date, quantity, price, transaction_type, description, created_at FROM transactions 
WHERE price IS NULL AND transaction_type IN ('IPO', 'REGULAR')
ORDER BY scrip, date ASC
`

func (q *Queries) GetTransactionsWithoutPrice(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsWithoutPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Scrip,
			&i.Date,
			&i.Quantity,
			&i.Price,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueScripList = `-- name: GetUniqueScripList :many
SELECT DISTINCT scrip FROM transactions 
ORDER BY scrip
`

func (q *Queries) GetUniqueScripList(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUniqueScripList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var scrip string
		if err := rows.Scan(&scrip); err != nil {
			return nil, err
		}
		items = append(items, scrip)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionPrice = `-- name: UpdateTransactionPrice :exec
UPDATE transactions 
SET price = ? 
WHERE id = ?
`

type UpdateTransactionPriceParams struct {
	Price sql.NullInt64
	ID    int64
}

func (q *Queries) UpdateTransactionPrice(ctx context.Context, arg UpdateTransactionPriceParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionPrice, arg.Price, arg.ID)
	return err
}
