// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: fundamentals.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getLatestFundamental = `-- name: GetLatestFundamental :one
SELECT id, company_id, fiscal_year, quarter, eps, pe_ratio, book_value, paid_up_capital, profit_amount, created_at, updated_at FROM fundamentals
WHERE company_id = ?
ORDER BY fiscal_year DESC, quarter DESC NULLS FIRST
LIMIT 1
`

func (q *Queries) GetLatestFundamental(ctx context.Context, companyID int64) (Fundamental, error) {
	row := q.db.QueryRowContext(ctx, getLatestFundamental, companyID)
	var i Fundamental
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.FiscalYear,
		&i.Quarter,
		&i.Eps,
		&i.PeRatio,
		&i.BookValue,
		&i.PaidUpCapital,
		&i.ProfitAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFundamentalsByCompany = `-- name: ListFundamentalsByCompany :many
SELECT id, company_id, fiscal_year, quarter, eps, pe_ratio, book_value, paid_up_capital, profit_amount, created_at, updated_at FROM fundamentals
WHERE company_id = ?
ORDER BY fiscal_year DESC, quarter DESC NULLS FIRST
`

func (q *Queries) ListFundamentalsByCompany(ctx context.Context, companyID int64) ([]Fundamental, error) {
	rows, err := q.db.QueryContext(ctx, listFundamentalsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fundamental
	for rows.Next() {
		var i Fundamental
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.FiscalYear,
			&i.Quarter,
			&i.Eps,
			&i.PeRatio,
			&i.BookValue,
			&i.PaidUpCapital,
			&i.ProfitAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFundamental = `-- name: UpsertFundamental :exec
INSERT INTO fundamentals (company_id, fiscal_year, quarter, eps, pe_ratio, book_value, paid_up_capital, profit_amount, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(company_id, fiscal_year, quarter) DO UPDATE SET
  eps = excluded.eps,
  pe_ratio = excluded.pe_ratio,
  book_value = excluded.book_value,
  paid_up_capital = excluded.paid_up_capital,
  profit_amount = excluded.profit_amount,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertFundamentalParams struct {
	CompanyID     int64           `json:"company_id"`
	FiscalYear    string          `json:"fiscal_year"`
	Quarter       sql.NullString  `json:"quarter"`
	Eps           sql.NullFloat64 `json:"eps"`
	PeRatio       sql.NullFloat64 `json:"pe_ratio"`
	BookValue     sql.NullFloat64 `json:"book_value"`
	PaidUpCapital sql.NullFloat64 `json:"paid_up_capital"`
	ProfitAmount  sql.NullFloat64 `json:"profit_amount"`
}

func (q *Queries) UpsertFundamental(ctx context.Context, arg UpsertFundamentalParams) error {
	_, err := q.db.ExecContext(ctx, upsertFundamental,
		arg.CompanyID,
		arg.FiscalYear,
		arg.Quarter,
		arg.Eps,
		arg.PeRatio,
		arg.BookValue,
		arg.PaidUpCapital,
		arg.ProfitAmount,
	)
	return err
}
