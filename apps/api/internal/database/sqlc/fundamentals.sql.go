// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: fundamentals.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getLatestFundamental = `-- name: GetLatestFundamental :one
SELECT id, company_id, fiscal_year, quarter, eps, pe_ratio, book_value, paid_up_capital, profit_amount, created_at, updated_at FROM fundamentals
WHERE company_id = ?
ORDER BY fiscal_year DESC,
  CASE
    WHEN quarter = '' THEN 5
    WHEN quarter = 'Fourth Quarter' THEN 4
    WHEN quarter = 'Third Quarter' THEN 3
    WHEN quarter = 'Second Quarter' THEN 2
    WHEN quarter = 'First Quarter' THEN 1
    ELSE 0
  END DESC
LIMIT 1
`

func (q *Queries) GetLatestFundamental(ctx context.Context, companyID int64) (Fundamental, error) {
	row := q.db.QueryRowContext(ctx, getLatestFundamental, companyID)
	var i Fundamental
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.FiscalYear,
		&i.Quarter,
		&i.Eps,
		&i.PeRatio,
		&i.BookValue,
		&i.PaidUpCapital,
		&i.ProfitAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSectorStats = `-- name: GetSectorStats :one
SELECT
  COUNT(DISTINCT c.id) as company_count,
  AVG(f.eps) as avg_eps,
  AVG(f.pe_ratio) as avg_pe_ratio,
  AVG(f.book_value) as avg_book_value
FROM companies c
INNER JOIN fundamentals f ON f.company_id = c.id
WHERE c.sector = ?
  AND f.id IN (
    SELECT f2.id FROM fundamentals f2
    WHERE f2.company_id = c.id
    ORDER BY f2.fiscal_year DESC,
      CASE
        WHEN f2.quarter = '' THEN 5
        WHEN f2.quarter = 'Fourth Quarter' THEN 4
        WHEN f2.quarter = 'Third Quarter' THEN 3
        WHEN f2.quarter = 'Second Quarter' THEN 2
        WHEN f2.quarter = 'First Quarter' THEN 1
        ELSE 0
      END DESC
    LIMIT 1
  )
`

type GetSectorStatsRow struct {
	CompanyCount int64           `json:"company_count"`
	AvgEps       sql.NullFloat64 `json:"avg_eps"`
	AvgPeRatio   sql.NullFloat64 `json:"avg_pe_ratio"`
	AvgBookValue sql.NullFloat64 `json:"avg_book_value"`
}

func (q *Queries) GetSectorStats(ctx context.Context, sector string) (GetSectorStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSectorStats, sector)
	var i GetSectorStatsRow
	err := row.Scan(
		&i.CompanyCount,
		&i.AvgEps,
		&i.AvgPeRatio,
		&i.AvgBookValue,
	)
	return i, err
}

const listFundamentalsByCompany = `-- name: ListFundamentalsByCompany :many
SELECT id, company_id, fiscal_year, quarter, eps, pe_ratio, book_value, paid_up_capital, profit_amount, created_at, updated_at FROM fundamentals
WHERE company_id = ?
ORDER BY fiscal_year DESC,
  CASE
    WHEN quarter = '' THEN 5
    WHEN quarter = 'Fourth Quarter' THEN 4
    WHEN quarter = 'Third Quarter' THEN 3
    WHEN quarter = 'Second Quarter' THEN 2
    WHEN quarter = 'First Quarter' THEN 1
    ELSE 0
  END DESC
`

func (q *Queries) ListFundamentalsByCompany(ctx context.Context, companyID int64) ([]Fundamental, error) {
	rows, err := q.db.QueryContext(ctx, listFundamentalsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fundamental
	for rows.Next() {
		var i Fundamental
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.FiscalYear,
			&i.Quarter,
			&i.Eps,
			&i.PeRatio,
			&i.BookValue,
			&i.PaidUpCapital,
			&i.ProfitAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFundamental = `-- name: UpsertFundamental :exec
INSERT INTO fundamentals (company_id, fiscal_year, quarter, eps, pe_ratio, book_value, paid_up_capital, profit_amount, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(company_id, fiscal_year, quarter) DO UPDATE SET
  eps = excluded.eps,
  pe_ratio = excluded.pe_ratio,
  book_value = excluded.book_value,
  paid_up_capital = excluded.paid_up_capital,
  profit_amount = excluded.profit_amount,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertFundamentalParams struct {
	CompanyID     int64           `json:"company_id"`
	FiscalYear    string          `json:"fiscal_year"`
	Quarter       string          `json:"quarter"`
	Eps           sql.NullFloat64 `json:"eps"`
	PeRatio       sql.NullFloat64 `json:"pe_ratio"`
	BookValue     sql.NullFloat64 `json:"book_value"`
	PaidUpCapital sql.NullFloat64 `json:"paid_up_capital"`
	ProfitAmount  sql.NullFloat64 `json:"profit_amount"`
}

func (q *Queries) UpsertFundamental(ctx context.Context, arg UpsertFundamentalParams) error {
	_, err := q.db.ExecContext(ctx, upsertFundamental,
		arg.CompanyID,
		arg.FiscalYear,
		arg.Quarter,
		arg.Eps,
		arg.PeRatio,
		arg.BookValue,
		arg.PaidUpCapital,
		arg.ProfitAmount,
	)
	return err
}
