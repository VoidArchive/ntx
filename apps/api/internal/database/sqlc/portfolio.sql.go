// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: portfolio.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createPortfolio = `-- name: CreatePortfolio :one
INSERT INTO portfolios (user_id, name)
VALUES (?, ?)
RETURNING id, user_id, name, created_at
`

type CreatePortfolioParams struct {
	UserID int64  `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) CreatePortfolio(ctx context.Context, arg CreatePortfolioParams) (Portfolio, error) {
	row := q.db.QueryRowContext(ctx, createPortfolio, arg.UserID, arg.Name)
	var i Portfolio
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (portfolio_id, stock_symbol, transaction_type, quantity, unit_price, transaction_date)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, portfolio_id, stock_symbol, transaction_type, quantity, unit_price, transaction_date, created_at
`

type CreateTransactionParams struct {
	PortfolioID     int64     `json:"portfolio_id"`
	StockSymbol     string    `json:"stock_symbol"`
	TransactionType string    `json:"transaction_type"`
	Quantity        int64     `json:"quantity"`
	UnitPrice       float64   `json:"unit_price"`
	TransactionDate time.Time `json:"transaction_date"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.PortfolioID,
		arg.StockSymbol,
		arg.TransactionType,
		arg.Quantity,
		arg.UnitPrice,
		arg.TransactionDate,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PortfolioID,
		&i.StockSymbol,
		&i.TransactionType,
		&i.Quantity,
		&i.UnitPrice,
		&i.TransactionDate,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash)
VALUES (?, ?)
RETURNING id, email, password_hash, created_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const deletePortfolio = `-- name: DeletePortfolio :exec
DELETE FROM portfolios WHERE id = ? AND user_id = ?
`

type DeletePortfolioParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeletePortfolio(ctx context.Context, arg DeletePortfolioParams) error {
	_, err := q.db.ExecContext(ctx, deletePortfolio, arg.ID, arg.UserID)
	return err
}

const getHoldingsByPortfolio = `-- name: GetHoldingsByPortfolio :many
SELECT
    stock_symbol,
    SUM(CASE WHEN transaction_type = 'BUY' THEN quantity ELSE -quantity END) as net_quantity,
    SUM(CASE WHEN transaction_type = 'BUY' THEN quantity * unit_price ELSE 0 END) as total_buy_cost,
    SUM(CASE WHEN transaction_type = 'BUY' THEN quantity ELSE 0 END) as total_buy_quantity
FROM transactions
WHERE portfolio_id = ?
GROUP BY stock_symbol
HAVING net_quantity > 0
`

type GetHoldingsByPortfolioRow struct {
	StockSymbol      string          `json:"stock_symbol"`
	NetQuantity      sql.NullFloat64 `json:"net_quantity"`
	TotalBuyCost     sql.NullFloat64 `json:"total_buy_cost"`
	TotalBuyQuantity sql.NullFloat64 `json:"total_buy_quantity"`
}

func (q *Queries) GetHoldingsByPortfolio(ctx context.Context, portfolioID int64) ([]GetHoldingsByPortfolioRow, error) {
	rows, err := q.db.QueryContext(ctx, getHoldingsByPortfolio, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoldingsByPortfolioRow
	for rows.Next() {
		var i GetHoldingsByPortfolioRow
		if err := rows.Scan(
			&i.StockSymbol,
			&i.NetQuantity,
			&i.TotalBuyCost,
			&i.TotalBuyQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPortfolio = `-- name: GetPortfolio :one
SELECT id, user_id, name, created_at FROM portfolios WHERE id = ? AND user_id = ?
`

type GetPortfolioParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetPortfolio(ctx context.Context, arg GetPortfolioParams) (Portfolio, error) {
	row := q.db.QueryRowContext(ctx, getPortfolio, arg.ID, arg.UserID)
	var i Portfolio
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, created_at FROM users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const listPortfoliosByUser = `-- name: ListPortfoliosByUser :many
SELECT id, user_id, name, created_at FROM portfolios WHERE user_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListPortfoliosByUser(ctx context.Context, userID int64) ([]Portfolio, error) {
	rows, err := q.db.QueryContext(ctx, listPortfoliosByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Portfolio
	for rows.Next() {
		var i Portfolio
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByPortfolio = `-- name: ListTransactionsByPortfolio :many
SELECT id, portfolio_id, stock_symbol, transaction_type, quantity, unit_price, transaction_date, created_at
FROM transactions
WHERE portfolio_id = ?
ORDER BY transaction_date DESC, created_at DESC
`

func (q *Queries) ListTransactionsByPortfolio(ctx context.Context, portfolioID int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByPortfolio, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PortfolioID,
			&i.StockSymbol,
			&i.TransactionType,
			&i.Quantity,
			&i.UnitPrice,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
